import React, { useState, useEffect, useCallback } from 'react';
import Confetti from 'react-confetti';
import MyStatusView from './components/MyStatusView';
import StatusTableView from './components/StatusTableView';
import ManageEmployeesView from './components/ManageEmployeesView';
// Import WebSocket hooks/functions and API functions
import { getEmployees, addEmployee, useWebSocket, sendTypingUpdate as sendWsTypingUpdate } from './dataService';
import './App.css';

// Simulate logged-in user (Needs proper auth eventually)
// IMPORTANT: Update this ID based on the IDs generated by the backend (see backend/db.js logs)
const CURRENT_USER_ID = 'emp174413112365652'; // <<< MUST MATCH AN ID IN THE employees TABLE
const CURRENT_USER_NAME_FALLBACK = 'User'; // Fallback if ID not found
const CONFETTI_STORAGE_KEY_PREFIX = 'confettiLastShown_';

function App() {
  const [view, setView] = useState('myStatus');
  const [statuses, setStatuses] = useState({}); // { userId: { date: statusText } }
  const [employees, setEmployees] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [showConfetti, setShowConfetti] = useState(false);
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });
  const [isConnected, setIsConnected] = useState(false); // WebSocket connection status

  // --- Window Size Effect ---
  useEffect(() => {
    const handleResize = () => {
      setWindowSize({ width: window.innerWidth, height: window.innerHeight });
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // --- Initial Data Loading Effect ---
  useEffect(() => {
    async function loadData() {
      setIsLoading(true);
      try {
        // Only fetch employees initially. Statuses will come via WebSocket.
        const fetchedEmployees = await getEmployees() || []; // Ensure it's an array
        setEmployees(fetchedEmployees);

        // Check if current user exists after loading
        const currentUserExists = fetchedEmployees.some(emp => emp.id === CURRENT_USER_ID);
        if (!currentUserExists && fetchedEmployees.length > 0) {
            console.warn(`Simulated user ID ${CURRENT_USER_ID} not found in fetched employees. Please update CURRENT_USER_ID in App.jsx to a valid ID from the list:`, fetchedEmployees.map(e => e.id));
        } else if (fetchedEmployees.length === 0) {
             console.warn("No employees loaded from backend. Add employees via 'Manage Employees' tab or check backend.");
        }

      } catch (error) {
        console.error("Error loading initial employee data:", error);
      } finally {
        // Don't set isLoading false here, wait for WS connection and initial statuses
        // setIsLoading(false);
      }
    }
    loadData();
  }, []); // Run only on mount

  // --- WebSocket Message Handling ---
   const handleWebSocketMessage = useCallback((message) => {
    // console.log("App received WS message:", message);
    if (message.type === 'all_statuses') {
      console.log("Received initial statuses via WebSocket:", message.payload);
      setStatuses(message.payload || {});
      setIsLoading(false); // Loading finished once initial statuses arrive
    } else if (message.type === 'status_update') {
      const { userId, date, statusText } = message.payload;
      // console.log(`Received status update for ${userId} on ${date}`);
      setStatuses(prevStatuses => {
        // Avoid unnecessary state updates if data is identical
        if (prevStatuses[userId]?.[date] === statusText) {
            return prevStatuses;
        }
        const newStatuses = structuredClone(prevStatuses); // Deep clone
        if (!newStatuses[userId]) {
          newStatuses[userId] = {};
        }
        newStatuses[userId][date] = statusText;
        return newStatuses;
      });
      // Confetti logic is now handled in handleStatusChange when the *user* sends the update
    } else if (message.type === 'connection_status') {
        const connected = message.payload === 'open';
        setIsConnected(connected);
        if (!connected) {
            // If disconnected, maybe show loading again until reconnected?
            // setIsLoading(true); // Or handle differently
            console.warn("WebSocket disconnected.");
        } else {
            console.log("WebSocket connected/reconnected.");
            // If we were loading and WS connects, request statuses again?
            // The server should send `all_statuses` on connect automatically.
        }
    } else if (message.type === 'error') {
        console.error("Received error message from WebSocket:", message.message);
        alert(`Server error via WebSocket: ${message.message}`);
    }
  }, []); // No dependencies needed as it only uses setters or constants

  // --- WebSocket Connection Hook ---
  // Pass the memoized handler
  const { isConnected: wsConnectedStatus } = useWebSocket(handleWebSocketMessage);
   // Update local state based on hook's status
   useEffect(() => {
       // Only update state if the status actually changed
       if (wsConnectedStatus !== isConnected) {
           setIsConnected(wsConnectedStatus);
       }
   }, [wsConnectedStatus, isConnected]);


  // --- Confetti Effect ---
  useEffect(() => {
    let timer;
    if (showConfetti) {
      // console.log("Triggering confetti effect");
      timer = setTimeout(() => {
          // console.log("Stopping confetti effect");
          setShowConfetti(false)
      }, 5000); // Show for 5 seconds
    }
    return () => clearTimeout(timer);
  }, [showConfetti]);

  const triggerConfetti = useCallback(() => {
    // console.log("Attempting to trigger confetti...");
    setShowConfetti(true);
  }, []); // No dependencies needed

  // --- Event Handlers ---

  // Memoize handleStatusChange
  const handleStatusChange = useCallback((userId, date, statusText) => {
    // 1. Send update via WebSocket
    sendWsTypingUpdate(userId, date, statusText);

    // 2. Check conditions for triggering confetti (only for the current user)
    if (userId === CURRENT_USER_ID) {
      const today = new Date().toISOString().split('T')[0];
      if (date === today && statusText.trim() !== '') { // Check if it's for today and not empty
        const storageKey = `${CONFETTI_STORAGE_KEY_PREFIX}${userId}`;
        const lastShownDate = localStorage.getItem(storageKey);

        if (lastShownDate !== today) {
          // console.log(`Confetti condition met for ${userId} on ${today}. Triggering.`);
          triggerConfetti();
          localStorage.setItem(storageKey, today); // Store today's date
        } else {
            // console.log(`Confetti already shown for ${userId} today (${today}).`);
        }
      }
    }
  }, [triggerConfetti]); // Dependency: triggerConfetti (which is also memoized)

  // Memoize handleAddEmployee
  const handleAddEmployee = useCallback(async (employeeName) => {
    setIsLoading(true); // Indicate activity
    try {
        const newEmployee = await addEmployee(employeeName);
        if (newEmployee) {
          // Re-fetch employees to get the updated list including the new ID
          const updatedEmployees = await getEmployees() || [];
          setEmployees(updatedEmployees);
          alert(`Employee "${employeeName}" added successfully! ID: ${newEmployee.id}`);
        } else {
            // Handle case where addEmployee returns null (e.g., duplicate name)
             alert(`Failed to add employee "${employeeName}". Name might already exist.`);
        }
    } catch (error) {
        // Error already logged and alerted in handleFetch/addEmployee
        console.error("Error adding employee in component:", error);
    } finally {
        setIsLoading(false);
    }
  }, []); // No dependencies needed

  // --- Render Logic ---

  // Determine current user's name
  const currentUser = employees.find(emp => emp.id === CURRENT_USER_ID);
  const currentUserName = currentUser ? currentUser.name : CURRENT_USER_NAME_FALLBACK;

  // Show loading indicator more accurately
  // Loading = true if initial employee fetch hasn't finished OR if WS is not connected AND we don't have statuses yet
   const showLoadingIndicator = isLoading || (!isConnected && Object.keys(statuses).length === 0);


  return (
    <div className="app-container">
      {showConfetti && (
        <Confetti
          width={windowSize.width}
          height={windowSize.height}
          recycle={false}
          numberOfPieces={300}
          gravity={0.15}
        />
      )}

       <header className="app-header">
           <h1>Daily Status Update</h1>
           <div className={`connection-status ${isConnected ? 'connected' : 'disconnected'}`}>
               {isConnected ? '● Connected' : '○ Disconnected'}
           </div>
       </header>

      <nav>
        {/* Navigation Buttons */}
         <button onClick={() => setView('myStatus')} disabled={view === 'myStatus'} className={view === 'myStatus' ? 'active' : ''}>My Status</button>
         <button onClick={() => setView('statusTable')} disabled={view === 'statusTable'} className={view === 'statusTable' ? 'active' : ''}>Status Table</button>
         <button onClick={() => setView('manageEmployees')} disabled={view === 'manageEmployees'} className={view === 'manageEmployees' ? 'active' : ''}>Manage Employees</button>
      </nav>

      <main>
        {showLoadingIndicator ? (
          <div role="status" aria-live="polite">Loading data and connecting...</div>
        ) : (
          <>
            {view === 'myStatus' && (
              <MyStatusView
                // Ensure key changes if userId changes, although it's constant here
                key={CURRENT_USER_ID}
                userId={CURRENT_USER_ID}
                userName={currentUserName}
                // Pass only the relevant slice of statuses for this user?
                // No, StatusInput needs initialStatus for today, MyStatusView needs past days
                statuses={statuses}
                onStatusChange={handleStatusChange} // Pass the memoized handler
              />
            )}
            {view === 'statusTable' && (
              <StatusTableView statuses={statuses} employees={employees} />
            )}
            {view === 'manageEmployees' && (
              <ManageEmployeesView
                employees={employees}
                onAddEmployee={handleAddEmployee} // Pass the memoized handler
              />
            )}
          </>
        )}
      </main>
    </div>
  );
}

export default App;
